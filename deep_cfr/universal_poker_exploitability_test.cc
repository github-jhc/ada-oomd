// Copyright 2019 DeepMind Technologies Ltd. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "universal_poker_exploitability.h"

#include <Eigen/Core>
#include <ctime>
#include <functional>
#include <iostream>
#include <memory>

#include "absl/algorithm/container.h"
#include "absl/strings/str_join.h"
#include "open_spiel/algorithms/public_tree.h"
#include "open_spiel/algorithms/tabular_exploitability.h"
#include "open_spiel/canonical_game_strings.h"
#include "open_spiel/game_parameters.h"
#include "open_spiel/games/kuhn_poker.h"
#include "open_spiel/games/leduc_poker.h"
#include "open_spiel/games/universal_poker.h"
#include "open_spiel/policy.h"
#include "open_spiel/spiel.h"
#include "open_spiel/spiel_utils.h"
#include "open_spiel/tests/basic_tests.h"

namespace open_spiel {
namespace universal_poker {
namespace {

namespace testing = open_spiel::testing;

TabularPolicy GetOptimalKuhnPolicy(double alpha) {
  double three_alpha = 3 * alpha;
  std::unordered_map<std::string, ActionsAndProbs> policy;
  // Player 0
  policy["0"] = {{0, 1 - alpha}, {1, alpha}};
  policy["0pb"] = {{0, 1}, {1, 0}};
  policy["1"] = {{0, 1}, {1, 0}};
  policy["1pb"] = {{0, 2. / 3. - alpha}, {1, 1. / 3. + alpha}};
  policy["2"] = {{0, 1 - three_alpha}, {1, three_alpha}};
  policy["2pb"] = {{0, 0}, {1, 1}};

  // Player 1
  policy["0p"] = {{0, 2. / 3.}, {1, 1. / 3.}};
  policy["0b"] = {{0, 1}, {1, 0}};
  policy["1p"] = {{0, 1}, {1, 0}};
  policy["1b"] = {{0, 2. / 3.}, {1, 1. / 3.}};
  policy["2p"] = {{0, 0}, {1, 1}};
  policy["2b"] = {{0, 0}, {1, 1}};
  return TabularPolicy(policy);
}

void TestExploitability(const std::string& game_name, double expected_value) {
  // os exploitability
  std::shared_ptr<const Game> game = LoadGame(game_name);
  TabularPolicy policy = open_spiel::GetUniformPolicy(*game);
  double exploitability = algorithms::Exploitability(*game, policy);
  if (!Near(exploitability, expected_value)) {
    SpielFatalError(absl::StrCat("Exploitability was ", exploitability,
                                 " but expected ", expected_value));
  }
  // universal exploitability.
  std::unordered_map<std::string, GameParameters> game_parameters = {
      {"kuhn_poker", KuhnPokerParameters()},
      {"leduc_poker", LeducPokerParameters()},
      {"FHP_poker", FHPPokerParameters()}};
  std::shared_ptr<const Game> universal_game =
      LoadGame("universal_poker", game_parameters[game_name]);
  UniformPolicy universal_policy;
  UniversalPokerExploitability exp(*universal_game, universal_policy);
  for (int i = 0; i != 10; ++i) {
    double universal_exp = exp();
    std::cout << "test uniform " << i << ", exp = " << universal_exp
              << std::endl;
    if (!Near(universal_exp, expected_value)) {
      SpielFatalError(absl::StrCat("Universal Exploitability was ",
                                   universal_exp, " but expected ",
                                   expected_value));
    }
  }
}

void TestFirstExploitability(const std::string& game_name,
                             double expected_value) {
  // universal exploitability.
  std::unordered_map<std::string, GameParameters> game_parameters = {
      {"kuhn_poker", KuhnPokerParameters()},
      {"leduc_poker", LeducPokerParameters()},
      {"FHP_poker", FHPPokerParameters()}};
  std::shared_ptr<const Game> universal_game =
      LoadGame("universal_poker", game_parameters[game_name]);
  FristPolicy universal_policy;
  UniversalPokerExploitability exp(*universal_game, universal_policy);
  double universal_exp = exp();
  if (!Near(universal_exp, expected_value)) {
    SpielFatalError(absl::StrCat("Universal Exploitability was ", universal_exp,
                                 " but expected ", expected_value));
  }
}

void TestRandomExploitability(const std::string& game_name) {
  // universal exploitability.
  std::unordered_map<std::string, GameParameters> game_parameters = {
      {"kuhn_poker", KuhnPokerParameters()},
      {"leduc_poker", LeducPokerParameters()},
      {"FHP2_poker", FHP2PokerParameters()}};
  std::shared_ptr<const Game> universal_game =
      LoadGame("universal_poker", game_parameters[game_name]);
  std::random_device rd;
  for (int ri = 0; ri != 10; ++ri) {
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dist(0, 1);
    RandomPolicy universal_policy(&gen, &dist);
    UniversalPokerExploitability exp(*universal_game, universal_policy);
    for (int i = 0; i != 10; ++i) {
      double universal_exp = exp();
      std::cout << "test random " << i << ", exp = " << universal_exp
                << std::endl;
    }
  }
}

int timeit(std::function<void()> func) {
  std::clock_t start = std::clock();
  func();
  int ms = (std::clock() - start) / (double)(CLOCKS_PER_SEC / 1000);
  return ms;
}
template <typename TimeT = std::chrono::milliseconds>
struct measure {
  template <typename F, typename... Args>
  static TimeT duration(F&& func, Args&&... args) {
    auto start = std::chrono::steady_clock::now();
    std::forward<decltype(func)>(func)(std::forward<Args>(args)...);
    return std::chrono::duration_cast<TimeT>(std::chrono::steady_clock::now() -
                                             start);
  }
};

void TestMultiThreadExploitability(const std::string& game_name) {
  // universal exploitability.
  std::unordered_map<std::string, GameParameters> game_parameters = {
      {"kuhn_poker", KuhnPokerParameters()},
      {"leduc_poker", LeducPokerParameters()},
      {"FHP2_poker", FHP2PokerParameters()}};
  std::shared_ptr<const Game> universal_game =
      LoadGame("universal_poker", game_parameters[game_name]);
  std::random_device rd;
  for (int ri = 0; ri != 10; ++ri) {
    std::mt19937 gen(ri);
    std::uniform_real_distribution<double> dist(0, 1);
    RandomPolicy universal_policy(&gen, &dist);
    double exp_value, multi_exp_value;
    {
      UniversalPokerExploitability exp(*universal_game, universal_policy);
      exp_value = exp();
      int single_time = measure<>::duration([&exp]() {
                          for (int i = 0; i != 10; ++i) exp();
                        }).count();
      std::cout << ri << ", Single thread expolitability, exp = " << exp()
                << " time = " << single_time << " ms" << std::endl;
    }
    {
      UniversalPokerExploitability multi_exp(*universal_game, universal_policy,
                                             nullptr, ri + 1);
      multi_exp_value = multi_exp();
      int threads_time = measure<>::duration([&multi_exp, ri]() {
                           for (int i = 0; i != 10; ++i) multi_exp();
                         }).count();
      std::cout << ri << ", " << ri + 1
                << " threads expolitability, exp = " << multi_exp()
                << " time = " << threads_time << " ms" << std::endl;
    }

    if (!Near(exp_value, multi_exp_value)) {
      SpielFatalError("multithread explitability error");
    }
  }
}

}  // namespace
}  // namespace universal_poker
}  // namespace open_spiel

int main(int argc, char** argv) {
  open_spiel::universal_poker::TestExploitability("kuhn_poker",
                                                  0.4583333333333335);
  open_spiel::universal_poker::TestExploitability("leduc_poker",
                                                  2.373611111111111);
  open_spiel::universal_poker::TestFirstExploitability("kuhn_poker", 1.0);
  open_spiel::universal_poker::TestFirstExploitability("leduc_poker", 1.0);

  open_spiel::universal_poker::TestRandomExploitability("kuhn_poker");
  open_spiel::universal_poker::TestRandomExploitability("leduc_poker");
  open_spiel::universal_poker::TestRandomExploitability("FHP2_poker");

  open_spiel::universal_poker::TestMultiThreadExploitability("kuhn_poker");
  open_spiel::universal_poker::TestMultiThreadExploitability("leduc_poker");
  open_spiel::universal_poker::TestMultiThreadExploitability("FHP2_poker");
}
